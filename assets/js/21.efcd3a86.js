(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{393:function(e,r,t){"use strict";t.r(r);var a=t(42),o=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[e._v("#")]),e._v(" 浏览器缓存")]),e._v(" "),t("p",[e._v("正确的进行缓存能够节省宽带，减低服务器成本，并加快响应速度，是性能优化的一大利器。")]),e._v(" "),t("p",[e._v("那么浏览器中的缓存又是怎样的？")]),e._v(" "),t("p",[e._v("其实，我们发送一个请求时，该请求会先在浏览器缓存中找到其匹配的资源，该过程会经历四个缓存的地方")]),e._v(" "),t("h2",{attrs:{id:"内存缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存缓存"}},[e._v("#")]),e._v(" 内存缓存")]),e._v(" "),t("p",[e._v("首先，它会在内存缓存（Memory Cache）中寻找。内存缓存有一个装满资源的容器。它包含当前文档获取并在文档生存期内保留的所有资源，如果请求寻找的资源已在当前文档的其他位置获取，则该资源将在内存缓存中找到。内存缓存的生存期是很短的，仅仅将资源保留到导航结束为止。")]),e._v(" "),t("p",[e._v("那么有哪些资源会被储存到内存缓存中呢？")]),e._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://calendar.perfplanet.com/2013/big-bad-preloader/",target:"_blank",rel:"noopener noreferrer"}},[e._v("预加载器"),t("OutboundLink")],1),e._v(' 可能是占内存缓存的资源最大的部分。如果请求是由 HTML 解析器创建 DOM 节点而创建的，则很有可能在 HTML 标记化（"tokenization"）阶段就已经获取到所需的资源。常见会被预加载的资源一般包括脚本，外部 CSS 和 '),t("code",[e._v("<img>")]),e._v(" 标签中的图像")])]),e._v(" "),t("li",[t("p",[e._v("通过显式的"),t("a",{attrs:{href:"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/",target:"_blank",rel:"noopener noreferrer"}},[e._v("预加载"),t("OutboundLink")],1),e._v("指令（"),t("code",[e._v("<link rel=preload>")]),e._v("）占据了另一大部分，其中预加载的资源也存储在内存缓存中")])])]),e._v(" "),t("h2",{attrs:{id:"service-worker-缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-worker-缓存"}},[e._v("#")]),e._v(" Service Worker 缓存")]),e._v(" "),t("blockquote",[t("p",[e._v("Service Worker 是浏览器独立于网页在后台运行的脚本。这些脚本使您可以访问不需要网页或用户交互的功能，例如推送通知、后台同步和离线体验。")])]),e._v(" "),t("p",[e._v("目前 Service Worker 已包括了推送通知和后台同步等功能，还可以拦截和处理网络请求，包括通过程序来管理缓存中的响应。")]),e._v(" "),t("p",[e._v("而 "),t("a",{attrs:{href:"https://developers.google.com/web/fundamentals/primers/service-workers",target:"_blank",rel:"noopener noreferrer"}},[e._v("Service Worker"),t("OutboundLink")],1),e._v(" 能够实现缓存是由于其具有 "),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Cache",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cache API"),t("OutboundLink")],1),e._v("，该 API 能够缓存请求的响应")]),e._v(" "),t("h2",{attrs:{id:"http-缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[e._v("#")]),e._v(" HTTP 缓存")]),e._v(" "),t("p",[e._v('HTTP 缓存也称为 "磁盘缓存"，其缓存的资源存储于硬盘中，读取速度较慢，与内存缓存相比，胜在存储容量和存储时效上。')]),e._v(" "),t("p",[e._v("浏览器命中的绝大部分缓存都来自 HTTP 缓存。")]),e._v(" "),t("h2",{attrs:{id:"推送缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#推送缓存"}},[e._v("#")]),e._v(" 推送缓存")]),e._v(" "),t("p",[e._v("推送缓存（Push Cache）是存储 HTTP/2 服务端推送资源的地方，该容器是不可持久的，仅在会话（session）中存在，如果会话终止，所有未与请求匹配的资源都失效。最重要的是，资源仅在有限的时间内保留在推送缓存容器中。（在基于 Chromium 的浏览器中约为 5 分钟）。")]),e._v(" "),t("p",[e._v("推送缓存根据其 URL 以及其各种请求标签将请求与资源匹配，但并不严格遵守 HTTP 头的缓存指令")]),e._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://calendar.perfplanet.com/2016/a-tale-of-four-caches/",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Tale of Four Caches"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=o.exports}}]);