(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{364:function(t,s,a){t.exports=a.p+"assets/img/memory-model.6312d0bb.svg"},402:function(t,s,a){"use strict";a.r(s);var r=a(44),v=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),r("h2",{attrs:{id:"变量的存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#变量的存储"}},[t._v("#")]),t._v(" 变量的存储")]),t._v(" "),r("p",[t._v("看一小段代码的变量在内存中是如何存储的？")]),t._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" name"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'稻草人'")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" c "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br")])]),r("p",[t._v("在内存模型中的存储如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:a(364),alt:"内存模型"}})]),t._v(" "),r("p",[t._v("JavaScript 中的变量是存储于堆栈中的，所以其垃圾回收就是回收堆栈中的变量")]),t._v(" "),r("h2",{attrs:{id:"回收栈中的垃圾"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回收栈中的垃圾"}},[t._v("#")]),t._v(" 回收栈中的垃圾")]),t._v(" "),r("p",[t._v("要回收调用栈中的垃圾是比较容易的，在调用栈中有一个"),r("strong",[t._v("记录当前执行状态的指针（ESP）")]),t._v("，指向调用栈中当前正在执行的上下文。例如当 foo 函数执行时，"),r("strong",[t._v("ESP")]),t._v(" 指向 foo 执行上下文，而当 foo 函数执行完毕，"),r("strong",[t._v("ESP")]),t._v(" 指针下移指向全局执行上下文，虽然 foo 函数的上下文还保存于栈内存中，但已是无效内存。")]),t._v(" "),r("h2",{attrs:{id:"回收堆中的垃圾"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回收堆中的垃圾"}},[t._v("#")]),t._v(" 回收堆中的垃圾")]),t._v(" "),r("p",[t._v("虽然 foo 函数的执行上下文已是无效内存，但保存在堆中的对象依然占用着空间，因此需要回收堆中的垃圾。要回收堆中的垃圾，需要 JavaScript 中的垃圾回收器。")]),t._v(" "),r("p",[t._v("在脚本中，绝大多数对象的生存期很短，只有某些对象的生存期较长，利用这一特点，V8 将堆进行分代，分为"),r("strong",[t._v("新生代")]),t._v("和"),r("strong",[t._v("老生代")]),t._v("两个区域，新生代存放生存期较短的对象，通常只有 1-8 M的空间，而老生代存放生存期较长的和较大的对象。")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("副垃圾回收器，回收新生代的垃圾。")])]),t._v(" "),r("li",[r("strong",[t._v("主垃圾回收器，回收老生代的垃圾。")])])]),t._v(" "),r("h3",{attrs:{id:"垃圾回收器的工作流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器的工作流程"}},[t._v("#")]),t._v(" 垃圾回收器的工作流程")]),t._v(" "),r("ol",[r("li",[t._v("标记空间中活跃对象和非活跃对象")]),t._v(" "),r("li",[t._v("回收非活跃队形所占用的内存，即清理垃圾")]),t._v(" "),r("li",[t._v("内存整理。回收对象后，一般会存在大量不连续的空间，称为"),r("strong",[t._v("内存碎片")]),t._v("。当内存中出现大量的内存碎片后，如果需要分配较大的连续内存的时候，就可能出现内存不足的情况，因此需要整理内存碎片。")])]),t._v(" "),r("h3",{attrs:{id:"副垃圾回收器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[t._v("#")]),t._v(" 副垃圾回收器")]),t._v(" "),r("p",[t._v("副垃圾回收器负责新生区的垃圾回收，大多数小的对象都会被分配到新生区。")]),t._v(" "),r("p",[t._v("由于新生区的垃圾回收频繁，因此使用 "),r("strong",[t._v("Scavenge")]),t._v(" 算法来处理，该算法把新生区划分为两个等大的子区："),r("strong",[t._v("对象区域")]),t._v("和"),r("strong",[t._v("空闲区域")]),t._v("，新加入的对象首先都会被存放到对象区域，当对象区域满时就执行垃圾回收了")]),t._v(" "),r("p",[t._v("首先对对象区域中的不活跃的死对象进行标记，标记完成之后，就进入垃圾清理阶段，副垃圾回收器会将对象区域活跃的对象复制到空闲区域，并且该过程是有序排列的，也就是说在复制过程也完成了内存整理操作。完成复制后，将对象区域和空闲区域交换，至此就完成了垃圾回收。")]),t._v(" "),r("p",[t._v("由于 Scavenge 算法需要将存活的对象从对象区域复制到空闲区域，该操作需要时间成本，若新生代空间设置得太大，那么清理的时间就会较长，所以"),r("strong",[t._v("为了执行效率，一般新生区的空间会被设置得较小")])]),t._v(" "),r("p",[t._v("由于新生代空间不大，所以很容易被存活的对象占满整个区域。为了解决这个问题，V8 采用了"),r("strong",[t._v("对象晋升策略")]),t._v("，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区。")]),t._v(" "),r("h3",{attrs:{id:"主垃圾回收器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[t._v("#")]),t._v(" 主垃圾回收器")]),t._v(" "),r("p",[t._v("主垃圾回收器主要负责老生区的垃圾回收。除了新生区晋升的对象，一些大的对象会直接被分配到老生区。")]),t._v(" "),r("p",[t._v("Scavenge 算法用于快速回收、紧缩小片内存效果很好，但对于大片内存则消耗过大，需要将空间划分为两个子区并且需要复制大对象操作，既浪费内存又执行效率低。因此主垃圾回收器采用**标记-清除（Mark-Sweep）"),r("strong",[t._v("与")]),t._v("标签-紧缩（Mark-Compact）**算法进行垃圾回收。")]),t._v(" "),r("p",[t._v("首先是标记过程，标记阶段是从一组根对象开始，递归遍历这组根对象，在这个过程中，能到达的对象称为"),r("strong",[t._v("活跃对象")]),t._v("，不能到达的对象就可以判断为"),r("strong",[t._v("垃圾对象")]),t._v("。根对象被定义为处于活跃状态，是浏览器或 V8 所引用的对象。例如全局对象属于根对象，因为它们始终可以被访问。")]),t._v(" "),r("p",[t._v("接下来是垃圾的清除过程，清除掉被判断为垃圾对象的对象")]),t._v(" "),r("p",[t._v("由于在垃圾清理过程会产生大量的不连续的内存碎片，导致大对象无法被分配的问题，就需要使用另一种算法"),r("strong",[t._v("标记-紧缩")]),t._v("来处理，其标记过程与"),r("strong",[t._v("标记-清理")]),t._v("算法一样，只是在清理时将所有存活的对象都向一端引动，然后直接清理掉端边界以外的内存。")]),t._v(" "),r("h3",{attrs:{id:"增量标记与惰性清理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#增量标记与惰性清理"}},[t._v("#")]),t._v(" 增量标记与惰性清理")]),t._v(" "),r("p",[t._v("当一个堆很大且存在很多活跃对象时，标记-清理和标记-紧缩算法会执行的很慢，而在垃圾回收的过程会暂停 JavaScript 线程的执行，也就是说在这个过程中，JavaScript 代码将不会被执行，处理"),r("strong",[t._v("停顿")]),t._v("状态.")]),t._v(" "),r("p",[t._v("在 2012 年，Google 引入了"),r("strong",[t._v("增量标记")]),t._v("与"),r("strong",[t._v("惰性清理")]),t._v("来减少垃圾回收所引起的停顿，增量标记就是将标记过程分为一个个的子标记过程，同时让垃圾回收的标记过程和 JavaScript 执行脚本交替进行，直到标记阶段完成，如此可减少标记-清除和标记-紧缩算法的标记时间。当增量标记完成后，惰性清理就开始了。由于所有的对象已被标记，因此无需一次清理所有的垃圾，垃圾回收器会视需要逐一清理，知道所有的垃圾都清理完毕。")]),t._v(" "),r("h2",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),r("ul",[r("li",[t._v("浏览器工作原理与实践-垃圾回收：垃圾数据是如何自动回收的")]),t._v(" "),r("li",[r("a",{attrs:{href:"http://newhtml.net/v8-garbage-collection/",target:"_blank",rel:"noopener noreferrer"}},[t._v("V8 之旅： 垃圾回收器"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=v.exports}}]);